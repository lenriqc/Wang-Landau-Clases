#include <iostream>
#include <vector>
#include <cstdlib>
#include <ctime>
#include <cmath>
#include <sstream>
#include <fstream>
#include <string>
#include "modelo.h"
// #include "aleatorios.h"
// double beta;


using namespace std;

class Algoritmo{
  
  public:
    virtual void implementar_algoritmo()=0;
    virtual void sweep()=0;
    
    virtual double valor_de_beta()=0;
    virtual void aumentar_beta(double dx)=0;
    virtual void disminuir_beta(double dx)=0;
    
    virtual double calcular_magnetizacion()=0;
    virtual double calcular_energia()=0;


};



class Metropolis: public Algoritmo{
  
  private:
    Modelo* M;
    double beta;
    int N;
    
  public:

    Metropolis(Modelo* mod, double Beta): beta(Beta) {
      M = mod;
      N = M->numero_de_espines();
    }



    void implementar_algoritmo(){
      int a = M->elegir_espin();
      double dH = M->cambio_en_energia(a);
      double p;
      if (dH <= 0) {
	p=1;
	M->aceptar_cambio(a);
      }
      else {
	p = exp(-beta*dH);
	double r = drand();
	if (r<=p){
	  M->aceptar_cambio(a);
	}
      }
    }  
        
    void sweep()
    {
      for (int i=0; i<N; i++)
      {
	implementar_algoritmo();
      }
    }
    
    
    void aumentar_beta(double delta_parametro){
      beta += delta_parametro;
    }
    
    void disminuir_beta(double delta_parametro){
      beta -= delta_parametro;
    }
    
    double valor_de_beta(){
      return(beta);
    }
    
    
    double calcular_magnetizacion(){
      return (M->Magnetizacion());
    }
    
    double calcular_energia(){
      return (M->Hamiltoniano());
    }
  
};



class Wang-Landau: public Algoritmo{
  
  private:
    Modelo* M;
    double beta;
    int N;
    
  public:

    Metropolis(Modelo* mod, double Beta): beta(Beta) {
      M = mod;
      N = M->numero_de_espines();
    }



    void implementar_algoritmo(){
      int a = M->elegir_espin();
      double dH = M->cambio_en_energia(a);
      double p;
      if (dH <= 0) {
				p=1;
				M->aceptar_cambio(a);
      }
      else {
				p = exp(-beta*dH);
				double r = drand();
				if (r<=p){
	  			M->aceptar_cambio(a);
				}
      }
    }  
        
    void sweep()
    {
      for (int i=0; i<N; i++)
      {
	implementar_algoritmo();
      }
    }
    
    
    void aumentar_beta(double delta_parametro){
      beta += delta_parametro;
    }
    
    void disminuir_beta(double delta_parametro){
      beta -= delta_parametro;
    }
    
    double valor_de_beta(){
      return(beta);
    }
    
    
    double calcular_magnetizacion(){
      return (M->Magnetizacion());
    }
    
    double calcular_energia(){
      return (M->Hamiltoniano());
    }
  
};
